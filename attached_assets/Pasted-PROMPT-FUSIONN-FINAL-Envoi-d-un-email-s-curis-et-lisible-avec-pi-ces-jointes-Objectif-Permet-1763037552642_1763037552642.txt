PROMPT FUSIONN√â FINAL : Envoi d‚Äôun email s√©curis√© et lisible avec pi√®ces jointes
üéØ Objectif

Permettre √† l‚Äôutilisateur d‚Äôenvoyer depuis son espace personnel (dashboard)
ses documents et informations, afin que l‚Äôadministrateur re√ßoive un email complet, clair et lisible,
avec tous les fichiers joints (PDF, images, etc.), sans stockage sur le cloud (ex : Cloudinary).

Les fichiers sont :

v√©rifi√©s (type, taille, antivirus),

nettoy√©s (PDF + images),

envoy√©s √† l‚Äôadmin via SendGrid,

puis supprim√©s imm√©diatement du serveur pour s√©curit√©.

‚öôÔ∏è Stack technique

Backend : Node.js + Express

Upload : Multer

Antivirus : ClamAV (via node-clam)

Traitement images : Sharp

Nettoyage PDF : pdf-lib

Email : SendGrid

S√©curit√© : V√©rification type + taille + suppression auto

D√©ploiement : Render, Replit, ou Next.js (API Route compatible)

üóÇÔ∏è Structure du projet
/project-root
‚îÇ
‚îú‚îÄ‚îÄ server.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ /uploads
‚îî‚îÄ‚îÄ .env

‚öôÔ∏è Variables d‚Äôenvironnement (.env)
SENDGRID_API_KEY=ta_clef_api_sendgrid
ADMIN_EMAIL=admin@altusfinancegroup.com
PORT=3000

üíª CODE COMPLET (√† coller dans Replit, Render, ou Vercel API)
// server.js
import express from "express";
import multer from "multer";
import fs from "fs";
import path from "path";
import sharp from "sharp";
import { PDFDocument } from "pdf-lib";
import NodeClam from "clamscan";
import sgMail from "@sendgrid/mail";
import cors from "cors";
import dotenv from "dotenv";

dotenv.config();
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Configuration Multer : stockage temporaire
const upload = multer({
  dest: "uploads/",
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const allowed = [
      "application/pdf",
      "image/png",
      "image/jpeg",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    ];
    if (!allowed.includes(file.mimetype)) {
      return cb(new Error("Format non autoris√©. Seuls PDF, PNG, JPG, DOCX sont accept√©s."), false);
    }
    cb(null, true);
  },
});

app.post("/api/upload", upload.array("documents"), async (req, res) => {
  try {
    const { name, email, phone, subject, message, type } = req.body;
    const clamscan = await new NodeClam().init({ removeInfected: true });
    const attachments = [];

    // V√©rification + nettoyage
    for (const file of req.files) {
      const filePath = path.resolve(file.path);
      const { isInfected } = await clamscan.scanFile(filePath);

      if (isInfected) {
        fs.unlinkSync(filePath);
        return res.status(400).json({ error: `Le fichier ${file.originalname} est infect√© et a √©t√© supprim√©.` });
      }

      // Nettoyage PDF
      if (file.mimetype === "application/pdf") {
        const pdfDoc = await PDFDocument.load(fs.readFileSync(filePath));
        fs.writeFileSync(filePath, await pdfDoc.save());
      }

      // Nettoyage images
      if (["image/png", "image/jpeg"].includes(file.mimetype)) {
        const cleanedPath = `${filePath}_clean.jpg`;
        await sharp(filePath)
          .jpeg({ quality: 90 })
          .toFile(cleanedPath);
        fs.unlinkSync(filePath);
        file.path = cleanedPath;
      }

      // Conversion base64
      const content = fs.readFileSync(file.path).toString("base64");
      attachments.push({
        content,
        filename: file.originalname,
        type: file.mimetype,
        disposition: "attachment",
      });

      // Suppression fichier temporaire
      fs.unlinkSync(file.path);
    }

    // Contenu HTML de l'email
    const htmlContent = `
      <div style="font-family: Arial, sans-serif; padding: 20px;">
        <h2 style="color: #007bff;">üì© Nouvelle demande utilisateur</h2>
        <p><strong>Type :</strong> ${type || "Non sp√©cifi√©"}</p>
        <p><strong>Nom :</strong> ${name}</p>
        <p><strong>Email :</strong> ${email}</p>
        <p><strong>T√©l√©phone :</strong> ${phone || "Non fourni"}</p>
        <hr />
        <p><strong>Objet :</strong> ${subject || "Sans objet"}</p>
        <p><strong>Message :</strong></p>
        <p style="background:#f7f7f7; padding:10px; border-radius:8px;">${message}</p>
        <hr />
        <p>Les documents envoy√©s par l'utilisateur sont joints √† cet email.</p>
        <p style="font-size: 13px; color: gray;">Email automatique envoy√© par le syst√®me Altus Finance Group</p>
      </div>
    `;

    // Envoi via SendGrid
    await sgMail.send({
      to: process.env.ADMIN_EMAIL,
      from: "no-reply@altusfinancegroup.com",
      subject: `Nouvelle demande de ${name || "utilisateur"}`,
      html: htmlContent,
      attachments,
    });

    res.status(200).json({ success: true, message: "üì§ Documents envoy√©s avec succ√®s et s√©curis√©s ‚úÖ" });
  } catch (error) {
    console.error("Erreur:", error);
    res.status(500).json({ success: false, message: "‚ùå Erreur lors de l'envoi des fichiers" });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üöÄ Serveur actif sur le port ${PORT}`));

üßæ Avantages

‚úÖ Fichiers lisibles et intacts √† la r√©ception.
‚úÖ Protection antivirus et nettoyage avant envoi.
‚úÖ Aucun stockage externe (Cloudinary inutile).
‚úÖ Compatible Render, Replit, Vercel (API Route).
‚úÖ Suppression automatique des fichiers temporaires.
‚úÖ Envoi pro via SendGrid (no-reply@altusfinancegroup.com).
‚úÖ Contenu HTML clair, adapt√© √† Gmail / Outlook.
‚úÖ Conforme RGPD : aucune conservation locale.

üß± Option frontend (recommand√©e)

Tu peux ajouter c√¥t√© client (dans le dashboard utilisateur) :

Une limite de 5 Mo par fichier

Une v√©rification du type MIME avant upload

Un petit loader ou message de succ√®s/erreur clair